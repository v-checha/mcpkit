"use strict";(globalThis.webpackChunkmcpkit_docs=globalThis.webpackChunkmcpkit_docs||[]).push([[100],{4622(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>g,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"advanced/plugins-guide","title":"Plugins Guide","description":"Plugins are the recommended way to package and share reusable functionality in MCPKit. They can add middleware, hooks, expose APIs, and manage their own lifecycle.","source":"@site/docs/advanced/plugins-guide.md","sourceDirName":"advanced","slug":"/advanced/plugins-guide","permalink":"/mcpkit/docs/advanced/plugins-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/mcpkit-dev/mcpkit/tree/main/docs/docs/advanced/plugins-guide.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Plugin System","permalink":"/mcpkit/docs/advanced/plugins"},"next":{"title":"Server Composition","permalink":"/mcpkit/docs/advanced/composition"}}');var r=t(4848),s=t(8453);const l={sidebar_position:5},o="Plugins Guide",a={},c=[{value:"Quick Start",id:"quick-start",level:2},{value:"Using Built-in Plugins",id:"using-built-in-plugins",level:3},{value:"Creating a Simple Plugin",id:"creating-a-simple-plugin",level:3},{value:"Plugin Creation Methods",id:"plugin-creation-methods",level:2},{value:"createPlugin() - Simple Plugins",id:"createplugin---simple-plugins",level:3},{value:"definePlugin() - Configurable Plugins",id:"defineplugin---configurable-plugins",level:3},{value:"hooksPlugin() - Hooks Only",id:"hooksplugin---hooks-only",level:3},{value:"middlewarePlugin() - Middleware Only",id:"middlewareplugin---middleware-only",level:3},{value:"combinePlugins() - Merge Plugins",id:"combineplugins---merge-plugins",level:3},{value:"Plugin Context API",id:"plugin-context-api",level:2},{value:"Using Plugin State",id:"using-plugin-state",level:3},{value:"Accessing Other Plugins",id:"accessing-other-plugins",level:3},{value:"Plugin Lifecycle",id:"plugin-lifecycle",level:2},{value:"Lifecycle Example",id:"lifecycle-example",level:3},{value:"Real-World Plugin Examples",id:"real-world-plugin-examples",level:2},{value:"Database Connection Plugin",id:"database-connection-plugin",level:3},{value:"Request Logging Plugin",id:"request-logging-plugin",level:3},{value:"Feature Flags Plugin",id:"feature-flags-plugin",level:3},{value:"Plugin Registry",id:"plugin-registry",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"plugins-guide",children:"Plugins Guide"})}),"\n",(0,r.jsx)(n.p,{children:"Plugins are the recommended way to package and share reusable functionality in MCPKit. They can add middleware, hooks, expose APIs, and manage their own lifecycle."}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsx)(n.h3,{id:"using-built-in-plugins",children:"Using Built-in Plugins"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import {\n  MCPServer,\n  metricsPlugin,\n  healthPlugin,\n  tracingPlugin,\n  createMetricsCollector,\n  createHealthChecker,\n  createTracer,\n  consoleExporter,\n} from '@mcpkit-dev/core';\n\n@MCPServer({\n  name: 'my-server',\n  version: '1.0.0',\n  plugins: [\n    metricsPlugin({ collector: createMetricsCollector({ prefix: 'myapp' }) }),\n    healthPlugin({ checker: createHealthChecker() }),\n    tracingPlugin({\n      tracer: createTracer({ serviceName: 'my-server', exporters: [consoleExporter()] }),\n    }),\n  ],\n})\nclass MyServer {}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-simple-plugin",children:"Creating a Simple Plugin"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { createPlugin } from '@mcpkit-dev/core';\n\nconst loggingPlugin = createPlugin({\n  name: 'logging',\n  version: '1.0.0',\n  description: 'Logs all tool calls',\n\n  // Add middleware\n  middleware: async (ctx, next) => {\n    console.error(`[${new Date().toISOString()}] ${ctx.method} ${ctx.path}`);\n    await next();\n  },\n\n  // Add hooks\n  hooks: {\n    onToolCall: ({ toolName, args }) => {\n      console.error(`Tool called: ${toolName}`, args);\n    },\n    onToolSuccess: ({ toolName, duration }) => {\n      console.error(`Tool succeeded: ${toolName} (${duration}ms)`);\n    },\n    onToolError: ({ toolName, error }) => {\n      console.error(`Tool failed: ${toolName}`, error.message);\n    },\n  },\n});\n\n@MCPServer({\n  name: 'my-server',\n  version: '1.0.0',\n  plugins: [loggingPlugin],\n})\nclass MyServer {}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"plugin-creation-methods",children:"Plugin Creation Methods"}),"\n",(0,r.jsx)(n.h3,{id:"createplugin---simple-plugins",children:"createPlugin() - Simple Plugins"}),"\n",(0,r.jsx)(n.p,{children:"For plugins that just need middleware and/or hooks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { createPlugin } from '@mcpkit-dev/core';\n\nconst simplePlugin = createPlugin({\n  name: 'simple',\n  version: '1.0.0',\n  description: 'A simple plugin',\n\n  // Single middleware or array\n  middleware: [\n    async (ctx, next) => { /* ... */ await next(); },\n    async (ctx, next) => { /* ... */ await next(); },\n  ],\n\n  // Hooks\n  hooks: {\n    onServerStart: () => console.error('Server started!'),\n    onServerStop: () => console.error('Server stopped!'),\n  },\n\n  // Lifecycle callbacks\n  onRegister: (ctx) => {\n    console.error('Plugin registered');\n  },\n  onBeforeStart: (ctx) => {\n    console.error('About to start');\n  },\n  onServerStart: (ctx, server) => {\n    console.error('Server is running');\n  },\n  onServerStop: (ctx) => {\n    console.error('Server stopped');\n  },\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"defineplugin---configurable-plugins",children:"definePlugin() - Configurable Plugins"}),"\n",(0,r.jsx)(n.p,{children:"For plugins that need configuration and expose an API:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { definePlugin } from '@mcpkit-dev/core';\n\ninterface CacheOptions {\n  ttl?: number;\n  maxSize?: number;\n}\n\ninterface CacheApi {\n  get: (key: string) => unknown;\n  set: (key: string, value: unknown) => void;\n  clear: () => void;\n  size: () => number;\n}\n\nconst cachePlugin = definePlugin<CacheOptions, CacheApi>({\n  name: 'cache',\n  version: '1.0.0',\n  description: 'In-memory caching plugin',\n\n  setup(options, ctx) {\n    const ttl = options?.ttl ?? 60000;\n    const maxSize = options?.maxSize ?? 1000;\n    const cache = new Map<string, { value: unknown; expires: number }>();\n\n    // Cleanup expired entries periodically\n    const cleanup = setInterval(() => {\n      const now = Date.now();\n      for (const [key, entry] of cache) {\n        if (entry.expires < now) cache.delete(key);\n      }\n    }, ttl);\n\n    // Register cleanup on stop\n    ctx.onStop(() => clearInterval(cleanup));\n\n    // Add middleware\n    ctx.useMiddleware(async (ctx, next) => {\n      ctx.set('cache', cache);\n      await next();\n    });\n\n    // Return API\n    return {\n      get: (key) => {\n        const entry = cache.get(key);\n        if (!entry || entry.expires < Date.now()) return undefined;\n        return entry.value;\n      },\n      set: (key, value) => {\n        if (cache.size >= maxSize) {\n          const firstKey = cache.keys().next().value;\n          if (firstKey) cache.delete(firstKey);\n        }\n        cache.set(key, { value, expires: Date.now() + ttl });\n      },\n      clear: () => cache.clear(),\n      size: () => cache.size,\n    };\n  },\n});\n\n// Usage\n@MCPServer({\n  plugins: [cachePlugin({ ttl: 30000, maxSize: 500 })],\n})\nclass MyServer {}\n\n// Access API (after server starts)\nconst cache = server.getPluginApi<CacheApi>('cache');\ncache.set('key', 'value');\n"})}),"\n",(0,r.jsx)(n.h3,{id:"hooksplugin---hooks-only",children:"hooksPlugin() - Hooks Only"}),"\n",(0,r.jsx)(n.p,{children:"For plugins that only add hooks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { hooksPlugin } from '@mcpkit-dev/core';\n\nconst auditPlugin = hooksPlugin('audit', {\n  onToolCall: async ({ toolName, args, timestamp }) => {\n    await auditLog.write({\n      event: 'tool_call',\n      tool: toolName,\n      args,\n      timestamp,\n    });\n  },\n  onToolError: async ({ toolName, error, timestamp }) => {\n    await auditLog.write({\n      event: 'tool_error',\n      tool: toolName,\n      error: error.message,\n      timestamp,\n    });\n  },\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"middlewareplugin---middleware-only",children:"middlewarePlugin() - Middleware Only"}),"\n",(0,r.jsx)(n.p,{children:"For plugins that only add middleware:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { middlewarePlugin } from '@mcpkit-dev/core';\n\nconst corsPlugin = middlewarePlugin('cors',\n  async (ctx, next) => {\n    ctx.response.setHeader('Access-Control-Allow-Origin', '*');\n    ctx.response.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n    await next();\n  }\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"combineplugins---merge-plugins",children:"combinePlugins() - Merge Plugins"}),"\n",(0,r.jsx)(n.p,{children:"Combine multiple plugins into one:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { combinePlugins, createPlugin } from '@mcpkit-dev/core';\n\nconst securityBundle = combinePlugins(\n  'security-bundle',\n  '1.0.0',\n  [\n    authPlugin({ secret: process.env.JWT_SECRET! }),\n    rateLimitPlugin({ maxRequests: 100 }),\n    corsPlugin({ origins: ['https://example.com'] }),\n  ]\n);\n\n@MCPServer({\n  plugins: [securityBundle],\n})\nclass MyServer {}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"plugin-context-api",children:"Plugin Context API"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"PluginContext"})," provides methods for plugins to interact with the server:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface PluginContext {\n  // Server info\n  serverName: string;\n  serverVersion: string;\n\n  // Add middleware\n  useMiddleware(middleware: Middleware): void;\n\n  // Add hooks\n  useHooks(hooks: Partial<ServerHooks>): void;\n\n  // Plugin state (shared between lifecycle methods)\n  state: Map<string, unknown>;\n\n  // Get another plugin's API\n  getPlugin<T>(name: string): T | undefined;\n\n  // Register cleanup on stop\n  onStop(cleanup: () => void | Promise<void>): void;\n\n  // Logging (uses stderr for stdio compatibility)\n  log: {\n    debug: (message: string, ...args: unknown[]) => void;\n    info: (message: string, ...args: unknown[]) => void;\n    warn: (message: string, ...args: unknown[]) => void;\n    error: (message: string, ...args: unknown[]) => void;\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-plugin-state",children:"Using Plugin State"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const statefulPlugin = definePlugin<void, { getCounter: () => number }>({\n  name: 'stateful',\n  version: '1.0.0',\n\n  setup(_, ctx) {\n    // Store state\n    ctx.state.set('counter', 0);\n\n    ctx.useHooks({\n      onToolCall: () => {\n        const counter = ctx.state.get('counter') as number;\n        ctx.state.set('counter', counter + 1);\n      },\n    });\n\n    return {\n      getCounter: () => ctx.state.get('counter') as number,\n    };\n  },\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"accessing-other-plugins",children:"Accessing Other Plugins"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const dependentPlugin = definePlugin({\n  name: 'dependent',\n  version: '1.0.0',\n  dependencies: ['cache'], // Declare dependency\n\n  setup(_, ctx) {\n    // Get cache plugin's API\n    const cache = ctx.getPlugin<CacheApi>('cache');\n\n    if (!cache) {\n      throw new Error('Cache plugin is required');\n    }\n\n    ctx.useMiddleware(async (ctx, next) => {\n      const cacheKey = `response:${ctx.path}`;\n      const cached = cache.get(cacheKey);\n\n      if (cached) {\n        ctx.set('fromCache', true);\n        ctx.set('response', cached);\n        return;\n      }\n\n      await next();\n\n      const response = ctx.get('response');\n      if (response) {\n        cache.set(cacheKey, response);\n      }\n    });\n  },\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"plugin-lifecycle",children:"Plugin Lifecycle"}),"\n",(0,r.jsx)(n.p,{children:"Plugins go through these phases:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. Register     \u2192 onRegister(ctx)         - Plugin is added to server\n2. Initialize   \u2192 Middleware/hooks added  - Before server starts\n3. Before Start \u2192 onBeforeStart(ctx)      - Just before transport connects\n4. Start        \u2192 onServerStart(ctx, srv) - Server is running\n5. Stop         \u2192 onServerStop(ctx)       - Server is shutting down\n"})}),"\n",(0,r.jsx)(n.h3,{id:"lifecycle-example",children:"Lifecycle Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const lifecyclePlugin = definePlugin({\n  name: 'lifecycle-demo',\n  version: '1.0.0',\n\n  setup(_, ctx) {\n    ctx.log.info('1. Setup called');\n\n    // This runs during initialization\n    ctx.useMiddleware(async (ctx, next) => {\n      ctx.log.info('Middleware executing');\n      await next();\n    });\n\n    // Register cleanup\n    ctx.onStop(() => {\n      ctx.log.info('Cleanup on stop');\n    });\n\n    return {};\n  },\n\n  onRegister(ctx) {\n    ctx.log.info('2. Plugin registered');\n  },\n\n  onBeforeStart(ctx) {\n    ctx.log.info('3. About to start');\n  },\n\n  onServerStart(ctx, server) {\n    ctx.log.info('4. Server is running');\n    // Can access MCP server instance here\n  },\n\n  onServerStop(ctx) {\n    ctx.log.info('5. Server stopping');\n  },\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"real-world-plugin-examples",children:"Real-World Plugin Examples"}),"\n",(0,r.jsx)(n.h3,{id:"database-connection-plugin",children:"Database Connection Plugin"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { definePlugin } from '@mcpkit-dev/core';\nimport { Pool } from 'pg';\n\ninterface DbOptions {\n  connectionString: string;\n  maxConnections?: number;\n}\n\ninterface DbApi {\n  query: <T>(sql: string, params?: unknown[]) => Promise<T[]>;\n  transaction: <T>(fn: (client: PoolClient) => Promise<T>) => Promise<T>;\n}\n\nconst databasePlugin = definePlugin<DbOptions, DbApi>({\n  name: 'database',\n  version: '1.0.0',\n\n  async setup(options, ctx) {\n    const pool = new Pool({\n      connectionString: options.connectionString,\n      max: options.maxConnections ?? 10,\n    });\n\n    // Test connection\n    await pool.query('SELECT 1');\n    ctx.log.info('Database connected');\n\n    // Add health check\n    ctx.useHooks({\n      onServerStart: async () => {\n        ctx.log.info('Database pool ready');\n      },\n    });\n\n    // Cleanup on stop\n    ctx.onStop(async () => {\n      await pool.end();\n      ctx.log.info('Database pool closed');\n    });\n\n    // Make pool available in middleware context\n    ctx.useMiddleware(async (ctx, next) => {\n      ctx.set('db', pool);\n      await next();\n    });\n\n    return {\n      query: async (sql, params) => {\n        const result = await pool.query(sql, params);\n        return result.rows;\n      },\n      transaction: async (fn) => {\n        const client = await pool.connect();\n        try {\n          await client.query('BEGIN');\n          const result = await fn(client);\n          await client.query('COMMIT');\n          return result;\n        } catch (error) {\n          await client.query('ROLLBACK');\n          throw error;\n        } finally {\n          client.release();\n        }\n      },\n    };\n  },\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"request-logging-plugin",children:"Request Logging Plugin"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { createPlugin } from '@mcpkit-dev/core';\nimport { appendFile } from 'fs/promises';\n\ninterface LogEntry {\n  timestamp: string;\n  type: 'tool' | 'resource' | 'prompt';\n  name: string;\n  duration: number;\n  status: 'success' | 'error';\n  error?: string;\n}\n\nconst requestLoggerPlugin = createPlugin({\n  name: 'request-logger',\n  version: '1.0.0',\n\n  hooks: {\n    onToolSuccess: async ({ toolName, duration }) => {\n      await logEntry({\n        timestamp: new Date().toISOString(),\n        type: 'tool',\n        name: toolName,\n        duration,\n        status: 'success',\n      });\n    },\n    onToolError: async ({ toolName, duration, error }) => {\n      await logEntry({\n        timestamp: new Date().toISOString(),\n        type: 'tool',\n        name: toolName,\n        duration,\n        status: 'error',\n        error: error.message,\n      });\n    },\n    onResourceSuccess: async ({ uri, duration }) => {\n      await logEntry({\n        timestamp: new Date().toISOString(),\n        type: 'resource',\n        name: uri,\n        duration,\n        status: 'success',\n      });\n    },\n  },\n});\n\nasync function logEntry(entry: LogEntry) {\n  await appendFile('requests.log', JSON.stringify(entry) + '\\n');\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"feature-flags-plugin",children:"Feature Flags Plugin"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { definePlugin } from '@mcpkit-dev/core';\n\ninterface FeatureFlagsOptions {\n  flags: Record<string, boolean>;\n  refreshInterval?: number;\n}\n\ninterface FeatureFlagsApi {\n  isEnabled: (flag: string) => boolean;\n  setFlag: (flag: string, enabled: boolean) => void;\n  getAllFlags: () => Record<string, boolean>;\n}\n\nconst featureFlagsPlugin = definePlugin<FeatureFlagsOptions, FeatureFlagsApi>({\n  name: 'feature-flags',\n  version: '1.0.0',\n\n  setup(options, ctx) {\n    const flags = new Map(Object.entries(options.flags));\n\n    // Optionally refresh from external source\n    if (options.refreshInterval) {\n      const interval = setInterval(async () => {\n        // Fetch from external source\n        const newFlags = await fetchFlags();\n        for (const [key, value] of Object.entries(newFlags)) {\n          flags.set(key, value);\n        }\n      }, options.refreshInterval);\n\n      ctx.onStop(() => clearInterval(interval));\n    }\n\n    // Make flags available in context\n    ctx.useMiddleware(async (ctx, next) => {\n      ctx.set('featureFlags', flags);\n      await next();\n    });\n\n    return {\n      isEnabled: (flag) => flags.get(flag) ?? false,\n      setFlag: (flag, enabled) => flags.set(flag, enabled),\n      getAllFlags: () => Object.fromEntries(flags),\n    };\n  },\n});\n\n// Usage in tool\n@Tool({ description: 'New feature' })\nasync newFeature() {\n  const flags = this.context.get('featureFlags') as Map<string, boolean>;\n  if (!flags.get('new-feature-enabled')) {\n    throw new Error('Feature not available');\n  }\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"plugin-registry",children:"Plugin Registry"}),"\n",(0,r.jsx)(n.p,{children:"For advanced use cases, access the plugin registry directly:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { createPluginRegistry } from '@mcpkit-dev/core';\n\nconst registry = createPluginRegistry('my-server', '1.0.0');\n\n// Register plugins\nregistry.register(loggingPlugin);\nregistry.register(cachePlugin({ ttl: 30000 }));\n\n// Initialize all plugins\nawait registry.initializeAll();\n\n// Get collected middleware and hooks\nconst middleware = registry.getMiddlewares();\nconst hooks = registry.getHooks();\n\n// Start all plugins\nawait registry.startAll(mcpServer);\n\n// Get plugin API\nconst cacheApi = registry.getPluginApi<CacheApi>('cache');\n\n// Stop all plugins\nawait registry.stopAll();\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Name plugins clearly"})," - Use descriptive names like ",(0,r.jsx)(n.code,{children:"database"}),", ",(0,r.jsx)(n.code,{children:"cache"}),", ",(0,r.jsx)(n.code,{children:"auth"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Version your plugins"})," - Follow semver for breaking changes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Declare dependencies"})," - Use ",(0,r.jsx)(n.code,{children:"dependencies"})," array for required plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clean up resources"})," - Use ",(0,r.jsx)(n.code,{children:"ctx.onStop()"})," to release connections, timers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use ctx.log"})," - It writes to stderr, safe for stdio transport"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Expose minimal API"})," - Only expose what consumers need"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle errors gracefully"})," - Don't let plugin errors crash the server"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Document configuration"})," - TypeScript interfaces make options clear"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/mcpkit/docs/advanced/plugins",children:"Plugins Reference"})," - Plugin API reference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/mcpkit/docs/advanced/middleware-utilities",children:"Middleware Utilities"})," - Advanced middleware"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/mcpkit/docs/guides/hooks",children:"Hooks Guide"})," - Server lifecycle hooks"]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>l,x:()=>o});var i=t(6540);const r={},s=i.createContext(r);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);