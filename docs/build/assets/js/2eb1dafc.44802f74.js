"use strict";(globalThis.webpackChunkmcpkit_docs=globalThis.webpackChunkmcpkit_docs||[]).push([[627],{7610(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"advanced/rate-limiting","title":"Rate Limiting","description":"Protect your server from abuse with configurable rate limiting.","source":"@site/docs/advanced/rate-limiting.md","sourceDirName":"advanced","slug":"/advanced/rate-limiting","permalink":"/mcpkit/docs/advanced/rate-limiting","draft":false,"unlisted":false,"editUrl":"https://github.com/v-checha/mcpkit/tree/main/docs/docs/advanced/rate-limiting.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Authentication","permalink":"/mcpkit/docs/advanced/authentication"},"next":{"title":"Plugin System","permalink":"/mcpkit/docs/advanced/plugins"}}');var i=t(4848),o=t(8453);const s={sidebar_position:3},a="Rate Limiting",l={},c=[{value:"HTTP Transport Rate Limiting",id:"http-transport-rate-limiting",level:2},{value:"Rate Limit Options",id:"rate-limit-options",level:2},{value:"Rate Limiting for Stdio",id:"rate-limiting-for-stdio",level:2},{value:"Option 1: Using Server Hooks",id:"option-1-using-server-hooks",level:3},{value:"Option 2: Per-Tool Rate Limiting Decorator",id:"option-2-per-tool-rate-limiting-decorator",level:3},{value:"Option 3: Global Rate Limiting for All Tools",id:"option-3-global-rate-limiting-for-all-tools",level:3},{value:"Transport Compatibility Summary",id:"transport-compatibility-summary",level:2},{value:"Custom Rate Limit Store",id:"custom-rate-limit-store",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rate-limiting",children:"Rate Limiting"})}),"\n",(0,i.jsx)(n.p,{children:"Protect your server from abuse with configurable rate limiting."}),"\n",(0,i.jsxs)(n.admonition,{title:"Important: HTTP Transport Required",type:"caution",children:[(0,i.jsxs)(n.p,{children:["Rate limiting middleware ",(0,i.jsx)(n.strong,{children:"only works with HTTP transports"})," (",(0,i.jsx)(n.code,{children:"streamable-http"}),", ",(0,i.jsx)(n.code,{children:"sse"}),"). It does ",(0,i.jsx)(n.strong,{children:"not"})," work with ",(0,i.jsx)(n.code,{children:"stdio"})," transport (the default), because stdio has no HTTP request/response cycle."]}),(0,i.jsxs)(n.p,{children:["If you're using stdio (e.g., with Claude Desktop), see ",(0,i.jsx)(n.a,{href:"#rate-limiting-for-stdio",children:"Rate Limiting for Stdio"})," below."]})]}),"\n",(0,i.jsx)(n.h2,{id:"http-transport-rate-limiting",children:"HTTP Transport Rate Limiting"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"rateLimit"})," middleware with HTTP transports:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { createServer, MCPServer, Tool, Param, rateLimit, MemoryRateLimitStore } from '@mcpkit-dev/core';\n\n@MCPServer({\n  name: 'rate-limited-server',\n  version: '1.0.0',\n  middleware: [\n    rateLimit({\n      windowMs: 60 * 1000, // 1 minute window\n      maxRequests: 100,    // 100 requests per window\n      keyGenerator: (ctx) => ctx.get('auth')?.principal?.userId ?? 'anonymous',\n      store: new MemoryRateLimitStore(),\n      onRateLimited: (ctx) => {\n        console.warn(`Rate limit exceeded for ${ctx.path}`);\n      },\n    }),\n  ],\n})\nclass RateLimitedServer {\n  @Tool({ description: 'My tool' })\n  async myTool(): Promise<string> {\n    return 'done';\n  }\n}\n\nconst server = createServer(RateLimitedServer);\n\n// Must use HTTP transport for middleware to work\nserver.listen({\n  transport: 'streamable-http',\n  port: 3000,\n  path: '/mcp',\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"rate-limit-options",children:"Rate Limit Options"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"rateLimit({\n  // Time window in milliseconds\n  windowMs: 60 * 1000,\n\n  // Maximum requests per window\n  maxRequests: 100,\n\n  // Function to generate a unique key for each client\n  keyGenerator: (ctx) => ctx.request.headers['x-api-key'] ?? 'anonymous',\n\n  // Storage backend (in-memory by default)\n  store: new MemoryRateLimitStore(),\n\n  // Callback when rate limit is exceeded\n  onRateLimited: (ctx) => {\n    console.warn(`Rate limited: ${ctx.path}`);\n  },\n\n  // Skip rate limiting for certain requests\n  skip: (ctx) => ctx.path === '/health',\n\n  // Custom response headers\n  headers: true,\n})\n"})}),"\n",(0,i.jsx)(n.h2,{id:"rate-limiting-for-stdio",children:"Rate Limiting for Stdio"}),"\n",(0,i.jsx)(n.p,{children:"For stdio transport (used by Claude Desktop), middleware doesn't run. Instead, use one of these approaches:"}),"\n",(0,i.jsx)(n.h3,{id:"option-1-using-server-hooks",children:"Option 1: Using Server Hooks"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import 'reflect-metadata';\nimport { createServer, MCPServer, Tool, Param, type ServerHooks } from '@mcpkit-dev/core';\n\n// Simple in-memory rate limiter for stdio\nclass StdioRateLimiter {\n  private calls: Map<string, number[]> = new Map();\n\n  constructor(\n    private windowMs: number,\n    private maxRequests: number\n  ) {}\n\n  check(key: string): { allowed: boolean; remaining: number; resetIn: number } {\n    const now = Date.now();\n    const windowStart = now - this.windowMs;\n\n    // Get existing calls and filter to current window\n    const calls = (this.calls.get(key) ?? []).filter((t) => t > windowStart);\n\n    if (calls.length >= this.maxRequests) {\n      const oldestCall = calls[0] ?? now;\n      return {\n        allowed: false,\n        remaining: 0,\n        resetIn: oldestCall + this.windowMs - now,\n      };\n    }\n\n    // Record this call\n    calls.push(now);\n    this.calls.set(key, calls);\n\n    return {\n      allowed: true,\n      remaining: this.maxRequests - calls.length,\n      resetIn: this.windowMs,\n    };\n  }\n}\n\n// 5 requests per minute\nconst rateLimiter = new StdioRateLimiter(60 * 1000, 5);\n\nconst hooks: ServerHooks = {\n  onToolCall: ({ toolName }) => {\n    const result = rateLimiter.check(toolName);\n    if (!result.allowed) {\n      throw new Error(\n        `Rate limit exceeded for \"${toolName}\". Try again in ${Math.ceil(result.resetIn / 1000)} seconds.`\n      );\n    }\n    console.error(`[rate-limit] ${toolName}: ${result.remaining} calls remaining`);\n  },\n};\n\n@MCPServer({\n  name: 'my-server',\n  version: '1.0.0',\n  hooks,\n})\nclass MyServer {\n  @Tool({ description: 'Add two numbers' })\n  async add(\n    @Param({ name: 'a' }) a: number,\n    @Param({ name: 'b' }) b: number\n  ): Promise<number> {\n    return a + b;\n  }\n}\n\nconst server = createServer(MyServer);\nserver.listen(); // stdio transport with rate limiting via hooks\n"})}),"\n",(0,i.jsx)(n.h3,{id:"option-2-per-tool-rate-limiting-decorator",children:"Option 2: Per-Tool Rate Limiting Decorator"}),"\n",(0,i.jsx)(n.p,{children:"Create a reusable decorator for tool-level rate limiting:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import 'reflect-metadata';\nimport { createServer, MCPServer, Tool, Param } from '@mcpkit-dev/core';\n\n// Rate limiter storage\nconst rateLimiters = new Map<string, { calls: number[]; windowMs: number; max: number }>();\n\nfunction RateLimit(maxRequests: number, windowMs: number = 60000): MethodDecorator {\n  return function (target: object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {\n    const original = descriptor.value;\n    const key = `${target.constructor.name}.${String(propertyKey)}`;\n\n    rateLimiters.set(key, { calls: [], windowMs, max: maxRequests });\n\n    descriptor.value = async function (...args: unknown[]) {\n      const limiter = rateLimiters.get(key)!;\n      const now = Date.now();\n      const windowStart = now - limiter.windowMs;\n\n      // Filter to current window\n      limiter.calls = limiter.calls.filter((t) => t > windowStart);\n\n      if (limiter.calls.length >= limiter.max) {\n        const resetIn = Math.ceil((limiter.calls[0]! + limiter.windowMs - now) / 1000);\n        throw new Error(`Rate limit exceeded. Try again in ${resetIn} seconds.`);\n      }\n\n      limiter.calls.push(now);\n      return original.apply(this, args);\n    };\n  };\n}\n\n@MCPServer({ name: 'my-server', version: '1.0.0' })\nclass MyServer {\n  @Tool({ description: 'Add two numbers' })\n  @RateLimit(2, 60000) // 2 calls per minute\n  async add(\n    @Param({ name: 'a' }) a: number,\n    @Param({ name: 'b' }) b: number\n  ): Promise<number> {\n    return a + b;\n  }\n\n  @Tool({ description: 'Multiply two numbers' })\n  @RateLimit(10, 60000) // 10 calls per minute (different limit)\n  async multiply(\n    @Param({ name: 'a' }) a: number,\n    @Param({ name: 'b' }) b: number\n  ): Promise<number> {\n    return a * b;\n  }\n}\n\nconst server = createServer(MyServer);\nserver.listen();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"option-3-global-rate-limiting-for-all-tools",children:"Option 3: Global Rate Limiting for All Tools"}),"\n",(0,i.jsx)(n.p,{children:"Apply a single rate limit across all tool calls:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import 'reflect-metadata';\nimport { createServer, MCPServer, Tool, Param, type ServerHooks } from '@mcpkit-dev/core';\n\n// Global rate limiter (all tools share the same limit)\nconst callTimes: number[] = [];\nconst WINDOW_MS = 60 * 1000; // 1 minute\nconst MAX_REQUESTS = 10;     // 10 total tool calls per minute\n\nconst hooks: ServerHooks = {\n  onToolCall: ({ toolName }) => {\n    const now = Date.now();\n    const windowStart = now - WINDOW_MS;\n\n    // Remove old calls outside the window\n    while (callTimes.length > 0 && callTimes[0]! < windowStart) {\n      callTimes.shift();\n    }\n\n    if (callTimes.length >= MAX_REQUESTS) {\n      const resetIn = Math.ceil((callTimes[0]! + WINDOW_MS - now) / 1000);\n      throw new Error(`Global rate limit exceeded. Try again in ${resetIn} seconds.`);\n    }\n\n    callTimes.push(now);\n    console.error(`[rate-limit] Global: ${MAX_REQUESTS - callTimes.length} calls remaining`);\n  },\n};\n\n@MCPServer({\n  name: 'my-server',\n  version: '1.0.0',\n  hooks,\n})\nclass MyServer {\n  @Tool({ description: 'Tool A' })\n  async toolA(): Promise<string> {\n    return 'A';\n  }\n\n  @Tool({ description: 'Tool B' })\n  async toolB(): Promise<string> {\n    return 'B';\n  }\n}\n\nconst server = createServer(MyServer);\nserver.listen();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"transport-compatibility-summary",children:"Transport Compatibility Summary"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Transport"}),(0,i.jsx)(n.th,{children:"Rate Limiting Method"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"streamable-http"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"middleware: [rateLimit(...)]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"sse"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"middleware: [rateLimit(...)]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"stdio"})," (default)"]}),(0,i.jsxs)(n.td,{children:["Use hooks or custom ",(0,i.jsx)(n.code,{children:"@RateLimit"})," decorator"]})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"custom-rate-limit-store",children:"Custom Rate Limit Store"}),"\n",(0,i.jsx)(n.p,{children:"For distributed deployments, implement a custom store (e.g., Redis):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { type RateLimitStore, type RateLimitInfo } from '@mcpkit-dev/core';\n\nclass RedisRateLimitStore implements RateLimitStore {\n  constructor(private redis: RedisClient) {}\n\n  async get(key: string): Promise<RateLimitInfo | undefined> {\n    const data = await this.redis.get(`ratelimit:${key}`);\n    return data ? JSON.parse(data) : undefined;\n  }\n\n  async set(key: string, info: RateLimitInfo, windowMs: number): Promise<void> {\n    await this.redis.setex(\n      `ratelimit:${key}`,\n      Math.ceil(windowMs / 1000),\n      JSON.stringify(info)\n    );\n  }\n\n  async increment(key: string): Promise<number> {\n    return await this.redis.incr(`ratelimit:${key}:count`);\n  }\n\n  async reset(key: string): Promise<void> {\n    await this.redis.del(`ratelimit:${key}`);\n  }\n}\n\n// Usage\n@MCPServer({\n  name: 'distributed-server',\n  version: '1.0.0',\n  middleware: [\n    rateLimit({\n      windowMs: 60 * 1000,\n      maxRequests: 100,\n      store: new RedisRateLimitStore(redisClient),\n    }),\n  ],\n})\nclass DistributedServer {}\n"})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>s,x:()=>a});var r=t(6540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);